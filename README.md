# 스프링이란?
자바 엔터프라이즈 애플리케이션 개발에 사용되는 애플리케이션 프레임워트이다.
애플리케이션의 바탕이 되는 틀과 공통 프로그래밍 모델, 기술 API 등을 제공해준다.

-  애플리케이션의 기본 틀 : 스프링 컨테이너
스프링은 애플리케이션 컨텍스트라는 컨테이너를 제공하는데, 이것은 애플리케이션 컴포넌트를 생성하고 관리한다. 애플리케이션 컴포넌트 또는 빈들은 스프링 애플리케이션 컨텍스트 내부에서 서로 연결되어 완전한 애플리케이션을 만든다.

# 의존성 주입
빈의 상호연결은 의존성 주입(DI) 패턴을 기반으로 수행되고, 애플리케이션 컴포넌트에서 의존(사용)하는 다른 빈의 생성과 관리를 자체적으로 하는 대신 별도의 개체(컨테이너)가 해주며, 이 개체에서는 모든 컴포넌트를 생성, 관리하고 해당 컴포넌트를 필요로 하는 빈에 주입(연결)한다.


- **@Configuration 어노테이션**

지금까지의 스프링 버전에서는 컴포넌트 및 다른 컴포넌트와의 관계를 나타내는 하나 이상의 XML 파일을 사용해서 빈을 상호 연결하도록 스프링 애플리케이션 컨텍스트에 알려주었다.

최신 버전의 스프링에서는 자바 기반의 구성 configuration이 더많이 사용된다.

configuration 어노테이션이 각 빈을 스프링 애플리케이션 컨텍스트에 제공하는 구성 클래스라는 것을 스프링에게 알려준다. 구성 클래스의 메서드에는 @Bean 어노테이션이 지정되어 있으며, 이것은 각 메서드에서 반환되는 객체가 애플리케이션 컨텍스트의 빈으로 추가되어야 한다는 것을 나타낸다.

## 공통 프로그래밍 모델 : loC/DI, 서비스 추상화, AOP
프레임워크는 애플리케이션을 구성하는 오브젝트가 생성되고 동작하는 방식에 대한 틀을 제공해줄 뿐만 아니라,
코드가 어떻게 작성돼야 하는지에 대한 기준도 제시해준다. 이것을 모델이라하며 스프링은 세가지 핵심 모델을 지원한다.


- **제어의 역전과 의존성 주입 : IoC(역전) DI(의존성 주입)**

빈 팩토리와 애플리케이션 컨텍스트

오브젝트의 생명주기와 의존관계에 대한 프로그래밍 모델
스프링은 유연하고 확장성이 뛰어난 코드를 만들 수 있게 도와주는 객체지향 설계 원칙과 디자인 패턴의 핵심 원리를 담고 있는 loC/DI 프레임워크의  근간으로 삼고있다.

- **IOC(Inversion of Control : 제어의 역전)**

자바 코드를 작성해 객체를 생성할 때는 객체가 필요한 곳에 직접 생성을 해야 한다.

```
public class A {
  b = new B(); // 클래스 A에서 new 키워드로 클래스 B의 객체 생성
}
```

제어의 역전은 다른 객체를 직접 생성하거나 제어하는 것이 아닌, 외부에서 관리하는 객체를 가져와 사용하는 것을 말한다. 위의 코드에서 제어의 역전을 적용한 코드는 아래와 같다.

~~~
public class A {
  private B b; // 코드에서 객체를 생성하지 않고, 어디선가 받아온 객체를 b에 할당한다.
}
~~~
클래스 B 객체를 직접 생성하는게 아니라 어딘가에서 받아와 사용하고 있다. 스프링은 **스프링 컨테이너가 객체를 관리, 제공하는 역할**을 해서 가능한 것이다.



- **DI(Dependency Injection : 의존성 주입)**

스프링에서는 객체들을 관리하기 위해 제어의 역전을 사용하고, 제어의 역전을 구현하기 위해 의존성 주입을 사용한다.
DI는 어떤 클래스가 다른 클래스에 의존한다는 것이다. @Autowired라는 어노테이션은 스프링 컨테이너에 있는 빈이라는 것을 주입하는 역할을 하며, **빈은 쉽게 말해서 스프링 컨테이너에서 관리하는 객체를 말한다.** 

IOC에서 사용한 코드에서는 B객체를 생성했지만 어딘가에서 B b;라고 선언 했을 뿐 직접 객체를 생성하지는 않고 있다.
```
public class A {
  @Autowired
  B b; // A에서 B를 주입받음
}
```
이렇게 객체를 주입받고 있는 것이다.

기존의 자바 코드라면 클래스 A에서 B객체를 쓰고 싶을 때 직접 생성했지만, 스프링의 경우는 클래스 A에서 B객체를 쓰고 싶을 때 스프링 컨테이너에서 객체를 주입받아 사용한다. 이것이 IoC/DI 개념이다.


- **PSA(Portable Service Abstraction : 서비스 추상화)**

스프링을 사용하면 환경이나 서버, 특정 기술에 종속되지 않고 **이식성**이 뛰어나며 유연한 애플리케이션을 만들 수 있다.
이를 가능하게 해주는 것이 바로 서비스 추상화이다. 구체적인 기술과 환경에 종속되지 않도록 유연한 추상 계층을 두는 방법이다. 예로 클라이언트의 매핑과 클랫, 메서드의 매핑을 위한 어노테이션이 있다. 스프링에서 데이터베이스에 접근하기 위한 기술로 JPA, MyBatis, JDBC 같은 것들이 있는데 여기서 어떤 기술을 사용하든 일관된 방식으로 데이터베이스에 접근하도록 인터페이스를 지원하는 것이다. 또 예시로 WAS도 PSA의 예 중 하나로 코드는 그대로 두며 WAS를 톰캣이 아닌 언더토우, 네티와 같은 다른 곳에서 실행하도 기존 코드를 그대로 사용할 수 있다.

- **AOP(Aspect Oriented Programming : 관점지향 프로그래밍)**

프로그래밍에 대한 관심을 **핵심관점, 부가 관점으로 나누어서 관심 기준으로 모듈화**를 하는 걸 의미한다.

애플리케이션 코드에 산재해서 나타나는 부가적인 기능을 독립적으로 모듈화하는 프로그래밍 모델이다. 스프링은 AOP를 이용해서, 다양한 엔터프라이즈 서비스를 적용하고도 깔끔한 코드를 유지할 수 있게 해준다.

예를 들어 계좌이체, 고객 관리를 하는 프로그램이라면 로깅 로직인 지금까지 벌어진 일을 기록하기 위한 로직과 여러 데이터를 관리하기 위한 데이터베이스 연결 로직이 포함된다. 이때 핵심 관점은 계좌이체와 고객 관리 로직이며 부가 관점이 로깅과 데이터베이스 연결로직이 된다. 로깅과 데이터베이스 연결은 모두 계좌이체와 고객관리에 필요하다. 여기에 AOP 관점을 적용한다면 부가 관점에 해당하는 로직을 모듈화해서 개발한다. 그러면 부가 관점 코드를 핵심 관점 코드에서 분리할 수 있게 된다. 그 결과 좀 더 핵심 관점 코드에만 집중할 수 있게 되며 변경과 확장에도 유연하게 대응할 수 있다.

```
IoC :  객체의 생성과 관리를 개발자가 하는게 아닌 프레임워크가 대신 한다.
DI : 외부에서 객체를 주입받아 사용한다.
AOP : 프로그래밍을 할 때 핵심 관점과 부가 관점을 나누어서 개발한다.
PSA : 어느 기술을 사용하던 일관된 방식으로 처리한다.
```


### 빈과 스프링 컨테이너
- **스프링 컨테이너 :**
스프링은 스프링 컨테이너를 제공한다. 스프링 컨테이너는 빈을 생성하고 관리한다. 즉, 빈이 생성되고 소멸되기까지 생명주기를 이 스프링 컨테이너가 관리하는 것이다. 또한 @Autowired 같은 어노테이션을 사용해 빈을 주입받을 수 있게 DI를 지원한다.

- **빈 :**

위의 코드에서 객체 B가 빈이다. 스프링은 빈을 스프링 컨테이너에 등록하기 위해 XML 파일 설정, 어노테이션 추가 등 여러 방법을 제공한다. 빈을 등록하는 방법은 여러 가지가 있으며 @Component 어노테이션을 붙이면 클래스가 빈으로 등록된다. 그러면 이후 스프링 컨테이너에서 이 빈을 관리해주게 된다. 이것은 스프링의 객체이다.


### 기술 API란? 
개발의 다양한 영역에 바로 활용할 수 있는 방대한 양의 기술 API를 제공한다. UI 작성은 물론이고 웹 프레젠테이션 계층, 비즈니스 서비스 계층, 기반 서비스 계층, 도메인 계층, 데이터 액세스 계층 등에서 필요한 주요 기술을 스프링에서 일관된 방식으로 사용할 수 있도록 지원해주는 기능과 전략 클래스 등을 제공한다. 스프링이 제공하는 API와 지원 기술은 모두 스프링의 프로그래밍 모델에 따라 작성되어 있기 때문에, 이를 가져다 쓰는 것만으로도 스프링의 프로그래밍 모델을 코드에 자연스럽게 적용할 수 있다.


### 스프링 자동구성
스프링 부트의 중요한 개념 중 하나로, 어플리케이션이 최소한의 설정만으로도 실행되게 여러 부분을 자동으로 구성해준다.
추후 개발을 하다가 직접 구성하지 않은 부분인데 스프링에서 자동으로 어떻게 구성했는지 확인할 사항이 오기 때문에 자동 구성 확인할 방법을 알아두어야 한다. 한다.

- **자동 설정이란?**  스프링 부트는 서버를 시작할 때 구성파일을 읽어와서 설정하는데 이것이 자동 설정이다.
- 자동설정 위치 : META-INF 에 있는 spring.factories
자동설정 위치에서 spring-boot-autocinfigure/spring.factories 파일을 열어보면 프로젝트에 쓰일 구성 후보들이 적혀 있고 스프링 부트를 시작할 때 이 파일에 설정되어 있는 클래스는 모두 불러오고 이후에는 프로젝트에서 사용할 것들만 자동으로 구성해 등록해준다.

스프링 부트에서는 빈이 자동으로 등록되고 구성되며 만약 자동 구성이 없다면 개발자가 특정 기술을 사용할 때마다 설정해야 하는 값을 모두 직접 선정해야 한다.


### 스프링 initializr 프로젝트 구조 생성 방법
- http://start.spring.io
- 명령행에서 curl 명령을 사용
- 명령해서 스프링 부트 CLI(command line interface)를 사용
- Spring Tool Suite IDE 사용으로 새로운 프로젝트 생성
- IntelliJ 또는 Eclipse IDE 사용
- NetBeans IDe 사용



### 레코드
레코드는 데이터 전달을 목적으로 하는 객체를 더 빠르고 간편하게 만들기 위한 기능으로 레코드는 상속을 할 수 없고 파라미터에 정의한 필드는 private final로 정의된다. 또한 레코드는 게터를 자동으로 만들기 때문에 어노테이션이나 메서드로 게터 정의를 하지 않아도 된다.




### 스프링 모듈
- spring-boot-starter-web : Spring MVC를 사용해서 RESTful 웹 서비스를 개발할 때 필요한 의존성 모음
- spring-boot-starter-test : 스프링 어플리케이션을 테스트하기 위해 필요한 의존성 모음
- spring-boot-starter-validation :  유효성 검사를 위해 필요한 의존성 모음
- spring-boot-starter-actuator : 모니터링을 위해 어플리케이션에서 제공하는 다양한 정보를 제공하기 쉽게 하는 의존성 모음
- spring-boot-satrter-data-jpa : ORM을 사용하기 위한 인터페이스의 모음인 JPA를 더 쉽게 사용하기 위한 의존성 모음


# 스프링 부트 구조
### 프레젠테이션 계층 : 컨트롤러 
HTTP 요청을 받고 이 요청을 비지니스 계층에 전송하는 역할이다.
컨트롤러가 바로 프레젠테이션 계층의 역할을 한다.
↕
### 비지니스 계층 : 서비스
모든 비지니스 로직을 처리하며, 서비스를 만들기 위한 로직이다.
웹 사이트에서 벌어지는 모든 작업으로 주문 서비스라 한다면 주문갯수, 가격 등의 데이터를 처리하기 위한 로직, 주문 처리를 하다 발생하는 예외처리 로직, 주문을 받거나 취소 하는 등의 프로세스를 구현하는 로직이다. 서비스가 비즈니스 계층의 역할을 한다.
↕
### 퍼시스턴스 계층 : 레파지토리
모든 데이터베이스 관련 로직을 처리하며 데이터베이스에 접근하는 DAO 객체를 사용할 수도 있다. DAO는 데이터 베이스 계층과 상호작용하기 위한 객체이며 레파지토리가 퍼시스턴스 계층의 역할을 한다.
↕
### 데이터베이스


# 테스트 코드
~~~
- spring-boot-starter-test : 스타터에 테스트를 위한 도구 모음
- Spring Test & Spring Boot Test : 스프링 부트 어플리케이션을 위한 통합 테스트 지원
~~~

test 디렉터리에서 작업하며 테스트 코드엔 `given-when-then` 같은 다양한 패턴이 있다.
- given :  테스트 실행을 준비하는 단계
- when : 테스트를 진행하는 단계
- then : 테스트 결과를 검증하는 단계

```
@DisplayName("새로운 메뉴를 저장한다.")
@Test
public void saveMenuTest() {
// given :  메뉴를 저장하기 위한 준비 과정
final String name = "아메리카노";
final int price = 2000;

// when : 실제로 메뉴를 저장
final long savedId = menuService.save(americano);

// then :  메뉴가 잘 추가되었는지 검증
final Menu savedMenu = menuService.findById(savedId).get();
assertThat(savedMenu.getName()).isEqualTo(name);
assertThat(savedMenu.getPrice()).isEqualTo(price);
}
```


- Hamcrest : 표현식을 보다 이해하기 쉽게 만드는 데 사용되는 Matcher 라이브러리
- Mockito : 테스트에 사용할 가짜 객체인 목 객체를 쉽게 만들고, 관리하고, 검증할 수 있게 지원하는 테스트 프레임워크
- JSONassert : JSON용 어설션 라이브러리
- JsonPath : JSON 데이터에서 특정 데이터를 선택하고 검색하기 위한 라이브러리


## JUnit : 자바 프로그래밍 언어용 단위 테스트 프레임워크
단위 테스트 프레임워크로 작성한 코드가 의도대로 작동되는지 작은 단위로 검증하는 것을 의미한다. 이때 보통 메서드가 된다. JUnit을 사용하면 단위 테스트를 작성하고 테스트하는데 도움을 준다. 테스트 결과가 직관적이라 좋고 구체적인 JUnit의 특징으로는 테스트 방식을 구분할 수 있는 어노테이션을 제공한다. @Test 어노테이션으로 메서드를 호출할 때 마다 새 인스턴스를 생성하고 독립 테스트가 가능하다. 예상 결과를 검증하는 어션설 메서드를 제공하고 사용방법이 단순하며, 테스트 코드 작성 시간이 적다. 자동실행, 자체 결과를 확인하고 즉각적인 피드백을 제공한다.


## AssertJ : 검증문인 어설션을 작성하는 데 사용되는 라이브러리
JUnit과 함께 사용해 검증문의 가독성을 높여주는 라이브러리이다.
`assertThat(a+b)/isEqualTo(sum);`
- isEquealto(A) : A 값과 같은지 검증
- isNotEqualTo(A) : A 값과 다른지 검증
- contains(A) : A값을 포함하는지 검증
- doesNotContain(A) : A 값을 포함하지 않는지 검증
- startsWith(A) : 접두사가 A인지 검증
- endsWith(A) : 접미사가 A인지 검증
- isEmpty() : 비어있는 값인지 검증
- isNotEmpty() : 비어있지 않은 값인지 검증
- isPositive() : 양수인지 검증
- isNegative() : 음수인지 검증
- isGreaterThan(1) : 1보다 큰 값인지 검증
- isLessThan(1) : 1보다 작은 값인지 검증


### HTTP 주요 응답코드
- isOk() :  200 OK
- isCreated() : 201 Created
- isBadRequest() :  400 Bad Request
- isForbidden() : 403 Forbidden
- isNOtFound() : 404 Not Found
- is4xxClientError() :  400번대 응답 코드
- isInternalErverError(): 500 Internal Server Error
- is5xxServerError() : 500번대 응답 코드

# 스프링 데이터

## 1. Service에서 JPA repository 
```
@Service
public class MemberServie {
@Autowired
MemberRepository memberRepository;

  public void test(){
    // ① 생성
    memberRepository.save(new Member(1L, "A"));
    // ② 조회
    Optional<member> member = memberRepository.findById(1L); // 단건 조회
    List<Member> allMembers = memberRepository.findAll();
    // ③ 삭제
    memberRepository.deltedById(1L);
  }
}
```


① 생성 Creat : save() 메서드
데이터 객체를 저장할 수 있으며, 전달 인수로 엔터티 Member를 넘기면 반환값으로 저장한 엔티티를 반환받을 수 있다.

② 조회 Select
- `findById()` 메서드에 id를 지정해 엔티티를 하나 조회할 수 있다.
- `findAll()` 메서드는 전체 엔티티를 조회한다.

③ 삭제 Delete
deletedById() 메서드에 id를 지정하면 엔티티를 삭제할 수 있다.


## 2. @Entity
~~~
@Entity // ① 엔티티로 지정
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED) // ② 기본 생성자
@AllArgsConstructor

public class Member {
  
  @Id // ③ id 필드를 기본키로 지정
  @GeneratedValue(strategy = GenerationType.IDENTITY) // ④ 기본키 자동으로 1씩 증가
  @Column(name = "id", updatable = false)
  privete Long id;
  
  @Column(name = "name", nullable = false) // ⑤ name이라는 notnull 컬럼과 매핑
  private String name;

}
~~~
- **① 엔티티로 지정**
Member 객체를 JPA가 관리하는 엔티티로 지정한다. 즉 Member 클래스와 실제 데이터베이스의 테이블을 매핑시킨다. 
- name 속성 : name의 값을 가진 테이블 이름과 매핑되고 테이블 이름을 지정하지 않으면 클래스 이름과 같은 이름의 테이블과 매핑된다.
```
@Entitu(name="member_list")
public class Article {
 ...
}
```

- **② 기본 생성자**
protected 기본 생성자로 엔티티는 반드시 기본 생성자가 있어야 하고, 접근 제어자는 public 또는 protected여야 한다. public 보다는 protected가 더 안전하므로 접근 제어자가 protected인 기본 생성자를 생성한다.

- **③ @Id 어노테이션 : id 필드를 기본키로 지정**

- **④ @GeneratedValue : 기본키의 생성 방식 결정**
```
AUTO : 선택한 데이터베이스 방언(dialect)에 따라 방식을 자동으로 선택(기본값)
IDENTITY : 기본 키 생성을 데이터베이스에 위임(=AUTO_INCREMENT)
SEQUENCE : 데이터베이스 시퀀스를 사용해서 기본 키를 할당하는 방법, 오라클에서 주로 사용
TABLE : 키 생성 테이블 사용
```
 
- **⑤ @Column : 데이터베이스의 컬럼과 필드를 매핑**
~~~
name : 필드와 매핑할 컬럼 이름, 설정하지 않으면 필드 이름으로 지정
nullable : 컬럼의 null 허용 여부, 설정하지 않으면 true(nullable)
unique : 컬럼의 유일한 값(unique) 여부, 설정하지 않으면 false(non-unique)
columnDefinition : 컬럼 정보 설정, default값을 줄 수 있다.
~~~

## 3. Repository
```
@Repository
public interface MemberRepository extends JpaRepository<Member, Long> {
}
```
엔터티에 있는 데이터들을 조회하거나 저장, 변경, 삭세즐 할 때 사용하는 인터페이스로 스프링 데이터 JPA에서 제공하는 인터페이스 JpaRepository 클래스를 상속받아 간단하게 구현할 수 있다. 상속받을 때 엔티티 클래스와 엔티티의 기본키 타입을 인수로 넣어준다.
